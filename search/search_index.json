{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Get Started This site contains the documents for Graphery, both the backend and the frontend. Things are still being updated and changed around here and there until the final public version is out. We are currently working on version 2, which is rewritten from the ground up with a lot of new features added. Can't wait to share the final product with you. :) You can checkout the introduction page to get a better sense of what's going on.","title":"Get Started"},{"location":"#get-started","text":"This site contains the documents for Graphery, both the backend and the frontend. Things are still being updated and changed around here and there until the final public version is out. We are currently working on version 2, which is rewritten from the ground up with a lot of new features added. Can't wait to share the final product with you. :) You can checkout the introduction page to get a better sense of what's going on.","title":"Get Started"},{"location":"guidelines/","text":"Guidelines Directory Structure The RFCs folder should be the root folder for all RFCs. No other folders should be create on the same level as the RFCs folder. That is, the following structure is not acceptable. . \u251c\u2500\u2500 RFCs \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 something else \u2514\u2500\u2500 ... There are currently three category folders under the root folder: backend , frontend , tutorials . The backend folder contains the RFCs that are related to the backend. Similarly, the RFCs for the frontend goes into the frontend folder. The tutorials folder contains the guidelines for the writers and editors of the tutorials. The subfolder, topic folder, in each category folder should concern one and only topic. The name of each directory should follower the naming convention for variables in Python, which means the name should be in lower case and each word is separated by _ . There should not be any loose documents aside from introduction.md and env_list.md in each category folder, that is, every document except introduction.md and env_list.md in a category folder should be contained in a topic folder. For example, . \u2514\u2500\u2500 RFCs \u251c\u2500\u2500 backend \u2502 \u251c\u2500\u2500 introduction.md \u2502 \u251c\u2500\u2500 env_list.md \u2502 \u251c\u2500\u2500 database_specification \u2502 \u2502 \u251c\u2500\u2500 guidelines.md \u2502 \u2502 \u251c\u2500\u2500 tutorial_table.md \u2502 \u2502 \u251c\u2500\u2500 member_table.md \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u2514\u2500\u2500 api_specification \u2502 \u251c\u2500\u2500 guidelines.md \u2502 \u251c\u2500\u2500 python_seeker_api.md \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 frontend \u2502 \u251c\u2500\u2500 env_list.md \u2502 \u251c\u2500\u2500 introduction.md \u2502 \u251c\u2500\u2500 ui_design \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u251c\u2500\u2500 data_storage_structure_design \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u2514\u2500\u2500 introduction.md \u2514\u2500\u2500 tutorials \u251c\u2500\u2500 introduction.md \u251c\u2500\u2500 for_writers \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 for_editors \u2514\u2500\u2500 ... Each topic folder may have subfolders. The subfolders should be used to compartmentalize the documents in the topic folder. The structure of the subfolders depends on the author of the topic folder. Document Naming Convention The name of each document should also follow the naming convention for variables in Python. That is, the name should be in lower case and each word is separated by _ . The names should be the clear, concise and impart the subject of that document. For example, the name of a document about websocket API can be websocket_api.md . Document Writing Document Structure Every document must be in markdown format and have one and only one H1 header which should be the same as the document file name except it should be in plain English. For example, the file name of this document is user_table.md , so the H1 header is User Table . Every document should concern one and only one topic. The subheaders should be in order. That is, a H3 header cannot be created without a H2 header as its parent. There are no restrictions on the internal structure of each document. Code Block Every code block should have a language indicator which is the string after the code fence (```). For example, ```python s = 'this is a string' print(s) ``` ```typescript var s = \"this is also a string\"; alert(s); ``` ```text this is just plain text ``` This is going to produce: s = 'this is a string' print ( s ) var s = \"this is also a string\" ; alert ( s ); this is just plain text Environment Variables There can be some places where authors would like to define some environment variables so that the values can be customized later. In this case, the environment variable should be indicated by a string enclosed in a code block (i.e. `` ) which starts with a dollar sign ( $ ) and the name of the variable matching the naming convention for constant variables. For example, a user should be removed if they have been unverified for some amount of time after the registration. The amount of time can be a environment variable $UNVERIFIED_USER_REMOVE_AFTER . All the environment variables should be compiled into the env_list.md file in the corresponding category folder by the creator. The environment variables in the env_list.md should link to the document where they are defined. That means when authors define a environment variable, it should be enclosed by <a id='env_name'> tag with an id attribute whose content is the name of the env varaible (the string after the $ sign). When referencing the variable in env_list.md , a hyper link should be used to point to the anchor in which the variable is defined. For example, <!-- Defining a environment variable --> <a id=\"ENV_VAR\">`$ENV_VAR`</a> <!-- Referencing a environment variable --> [ `$ENV_VAR` ](./some_document.md#ENV_VAR) Committing and Pushing Each commit should only concern one topic. Do not commit multiple files residing in different topic folders. All the RFCs should be pushed to RFCs-dev branch. They must be reviewed before being PRed to RFCs branch.","title":"Guidelines"},{"location":"guidelines/#guidelines","text":"","title":"Guidelines"},{"location":"guidelines/#directory-structure","text":"The RFCs folder should be the root folder for all RFCs. No other folders should be create on the same level as the RFCs folder. That is, the following structure is not acceptable. . \u251c\u2500\u2500 RFCs \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 something else \u2514\u2500\u2500 ... There are currently three category folders under the root folder: backend , frontend , tutorials . The backend folder contains the RFCs that are related to the backend. Similarly, the RFCs for the frontend goes into the frontend folder. The tutorials folder contains the guidelines for the writers and editors of the tutorials. The subfolder, topic folder, in each category folder should concern one and only topic. The name of each directory should follower the naming convention for variables in Python, which means the name should be in lower case and each word is separated by _ . There should not be any loose documents aside from introduction.md and env_list.md in each category folder, that is, every document except introduction.md and env_list.md in a category folder should be contained in a topic folder. For example, . \u2514\u2500\u2500 RFCs \u251c\u2500\u2500 backend \u2502 \u251c\u2500\u2500 introduction.md \u2502 \u251c\u2500\u2500 env_list.md \u2502 \u251c\u2500\u2500 database_specification \u2502 \u2502 \u251c\u2500\u2500 guidelines.md \u2502 \u2502 \u251c\u2500\u2500 tutorial_table.md \u2502 \u2502 \u251c\u2500\u2500 member_table.md \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u2514\u2500\u2500 api_specification \u2502 \u251c\u2500\u2500 guidelines.md \u2502 \u251c\u2500\u2500 python_seeker_api.md \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 frontend \u2502 \u251c\u2500\u2500 env_list.md \u2502 \u251c\u2500\u2500 introduction.md \u2502 \u251c\u2500\u2500 ui_design \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u251c\u2500\u2500 data_storage_structure_design \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u2514\u2500\u2500 introduction.md \u2514\u2500\u2500 tutorials \u251c\u2500\u2500 introduction.md \u251c\u2500\u2500 for_writers \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 for_editors \u2514\u2500\u2500 ... Each topic folder may have subfolders. The subfolders should be used to compartmentalize the documents in the topic folder. The structure of the subfolders depends on the author of the topic folder.","title":"Directory Structure"},{"location":"guidelines/#document-naming-convention","text":"The name of each document should also follow the naming convention for variables in Python. That is, the name should be in lower case and each word is separated by _ . The names should be the clear, concise and impart the subject of that document. For example, the name of a document about websocket API can be websocket_api.md .","title":"Document Naming Convention"},{"location":"guidelines/#document-writing","text":"","title":"Document Writing"},{"location":"guidelines/#document-structure","text":"Every document must be in markdown format and have one and only one H1 header which should be the same as the document file name except it should be in plain English. For example, the file name of this document is user_table.md , so the H1 header is User Table . Every document should concern one and only one topic. The subheaders should be in order. That is, a H3 header cannot be created without a H2 header as its parent. There are no restrictions on the internal structure of each document.","title":"Document Structure"},{"location":"guidelines/#code-block","text":"Every code block should have a language indicator which is the string after the code fence (```). For example, ```python s = 'this is a string' print(s) ``` ```typescript var s = \"this is also a string\"; alert(s); ``` ```text this is just plain text ``` This is going to produce: s = 'this is a string' print ( s ) var s = \"this is also a string\" ; alert ( s ); this is just plain text","title":"Code Block"},{"location":"guidelines/#environment-variables","text":"There can be some places where authors would like to define some environment variables so that the values can be customized later. In this case, the environment variable should be indicated by a string enclosed in a code block (i.e. `` ) which starts with a dollar sign ( $ ) and the name of the variable matching the naming convention for constant variables. For example, a user should be removed if they have been unverified for some amount of time after the registration. The amount of time can be a environment variable $UNVERIFIED_USER_REMOVE_AFTER . All the environment variables should be compiled into the env_list.md file in the corresponding category folder by the creator. The environment variables in the env_list.md should link to the document where they are defined. That means when authors define a environment variable, it should be enclosed by <a id='env_name'> tag with an id attribute whose content is the name of the env varaible (the string after the $ sign). When referencing the variable in env_list.md , a hyper link should be used to point to the anchor in which the variable is defined. For example, <!-- Defining a environment variable --> <a id=\"ENV_VAR\">`$ENV_VAR`</a> <!-- Referencing a environment variable --> [ `$ENV_VAR` ](./some_document.md#ENV_VAR)","title":"Environment Variables"},{"location":"guidelines/#committing-and-pushing","text":"Each commit should only concern one topic. Do not commit multiple files residing in different topic folders. All the RFCs should be pushed to RFCs-dev branch. They must be reviewed before being PRed to RFCs branch.","title":"Committing and Pushing"},{"location":"introduction/","text":"Introduction Graphery is a website aiming to provide useful visualizations of the execution process of classic graph algorithms on biological networks. It has two independent parts: the frontend and the backend. This set of RFCs is used to layout the structures of the two units and to prescribe the design decisions and API specifications. The guidelines for creating and updating the RFCs are specified in the guidelines.md file. When you update the RFCs, you should follow the rules.","title":"Introduction"},{"location":"introduction/#introduction","text":"Graphery is a website aiming to provide useful visualizations of the execution process of classic graph algorithms on biological networks. It has two independent parts: the frontend and the backend. This set of RFCs is used to layout the structures of the two units and to prescribe the design decisions and API specifications. The guidelines for creating and updating the RFCs are specified in the guidelines.md file. When you update the RFCs, you should follow the rules.","title":"Introduction"},{"location":"backend/env_list/","text":"$UNVERIFIED_USER_REMOVE_AFTER","title":"Env list"},{"location":"backend/introduction/","text":"Introduction These are specifications for the backend. It's subdivided into 5 major parts: database , api , middleware , services , and utilities . The following bulletin board lists the content of each topic folder. See the introduction.md file in each directory for more information. database directory contains the documents specifying each table schema, what they are for, and what's the role it plays. api directory contains API specifications. It includes frontend backend communication API and python seeker API. Middleware refers to the code that coordinates the communications between the database and user input through the API. The middleware directory contains the design decision of all the middleware. Services refers to the special applications on the website other than the tutorials. For example, it may include a banner system that deliveries messages as banner to users whenever the system admin pushes something out. The services directory contains the specifications of available services. Utilities refers to the helper class/functions accessible to developers. The utilities directory lists the design and usages of available utilities.","title":"Introduction"},{"location":"backend/introduction/#introduction","text":"These are specifications for the backend. It's subdivided into 5 major parts: database , api , middleware , services , and utilities . The following bulletin board lists the content of each topic folder. See the introduction.md file in each directory for more information. database directory contains the documents specifying each table schema, what they are for, and what's the role it plays. api directory contains API specifications. It includes frontend backend communication API and python seeker API. Middleware refers to the code that coordinates the communications between the database and user input through the API. The middleware directory contains the design decision of all the middleware. Services refers to the special applications on the website other than the tutorials. For example, it may include a banner system that deliveries messages as banner to users whenever the system admin pushes something out. The services directory contains the specifications of available services. Utilities refers to the helper class/functions accessible to developers. The utilities directory lists the design and usages of available utilities.","title":"Introduction"},{"location":"backend/api/introduction/","text":"Introduction This folder is intended to specify the API backend server exposes to the public. It currently has two sections, graphql and ws . In the graphql folder, three files, types.md , queries.md , and mutations.md details the a set of API following the GrahQL specs. In the ws folder, the only file denotes a set of API relying on pure websocket.","title":"Introduction"},{"location":"backend/api/introduction/#introduction","text":"This folder is intended to specify the API backend server exposes to the public. It currently has two sections, graphql and ws . In the graphql folder, three files, types.md , queries.md , and mutations.md details the a set of API following the GrahQL specs. In the ws folder, the only file denotes a set of API relying on pure websocket.","title":"Introduction"},{"location":"backend/api/graphql/introduction/","text":"Introduction This folder contains APIs in GraphQL specs. To edit the documents, you need to follow the guidelines below. Types The type system of GraphQL is defined here . All the types should have its own subheading and a table of the composition of types. The table should have three columns. The first one holds the field name; the second indicates the type of each field; the third describes what this field is for. For example: Comm Type (Type Example) Field Type description initiator String The name of the initiator of the communiaciton receivor String The name of the receiver attachment [package.File]! A list of files, where file is a custom type defined somewhere esle Query The query system is described here . All the types should also have its own subheading and a table of Mutations","title":"Introduction"},{"location":"backend/api/graphql/introduction/#introduction","text":"This folder contains APIs in GraphQL specs. To edit the documents, you need to follow the guidelines below.","title":"Introduction"},{"location":"backend/api/graphql/introduction/#types","text":"The type system of GraphQL is defined here . All the types should have its own subheading and a table of the composition of types. The table should have three columns. The first one holds the field name; the second indicates the type of each field; the third describes what this field is for. For example:","title":"Types"},{"location":"backend/api/graphql/introduction/#comm-type-type-example","text":"Field Type description initiator String The name of the initiator of the communiaciton receivor String The name of the receiver attachment [package.File]! A list of files, where file is a custom type defined somewhere esle","title":"Comm Type (Type Example)"},{"location":"backend/api/graphql/introduction/#query","text":"The query system is described here . All the types should also have its own subheading and a table of","title":"Query"},{"location":"backend/api/graphql/introduction/#mutations","text":"","title":"Mutations"},{"location":"backend/api/graphql/mutations/","text":"","title":"Mutations"},{"location":"backend/api/graphql/queries/","text":"Queries Versions 2.0 2.0","title":"Queries"},{"location":"backend/api/graphql/queries/#queries","text":"","title":"Queries"},{"location":"backend/api/graphql/queries/#versions","text":"2.0","title":"Versions"},{"location":"backend/api/graphql/queries/#2-0","text":"","title":"2.0"},{"location":"backend/api/graphql/types/","text":"","title":"Types"},{"location":"backend/api/ws/api/","text":"","title":"Api"},{"location":"backend/data_bridge/base/","text":"Bridge Base This file contains building blocks helping construct data bridge objects. It contains DataBridgeMeta , DataBridgeProtocol , and DataBridgeBase . DataBridgeMeta is a meta class implemented by DataBridgeProtocol . It constructs data bridge subclasses such each subclass will contain a collection of bridge functions , which are functions that validate input and write to the database. The DataBridgeProtocol is a protocol class constructed using the DataBridgeMeta , serving both as a source of attribute types and type reference in other context. The DataBridgeBase inherits DataBridgeProtocol and thus implements DataBridgeMeta . All data bridge classes should inherits DataBridgeBase instead of other bases. Every data bridge class must override the class attribute _bridged_model_cls so that it contains the Django model class as an indication that the the instances of this data bridge class will pipe inputs to that kind of Django model instance. As a result, in the creation process of the data bridge class, DataBridgeMeta serves as its meta class and collects bridge functions , which will be stored in _bridges class variable. DataBridgeMeta also makes sure the naming of bridge functions align with the fields in the model specified in _bridged_model_cls . Bridge functions are like pipes or middleware between API inputs and the database. It validates the input data and safely stores it into the database. Bridge functions should have their name start with the name _bridges_ following with the field name, that is, it follows the format _bridges_<field_name> . For example, _bridges_status is a bridge function operating on the field status . If the <field_name> of some bridge function is not present in Django model, an error will be raised. If some field in the _bridge_model does not have a bridge function, an error will be raised only if programmers try to pipe data to the field through the data bridge to that particular field. The metaclass also wraps each bridge function with a basic permission validator. Whether or not a permission and which level of permission is required should be indicated in the class variable _require_authentication and _minimal_user_role . It's defaulted to be open to everyone. In addition, there is a _custom_fields class attribute and a _attaching_to class attribute. _custom_fields allows bridge functions whose <field_name> is not specified in the corresponding Django model to exist. For example, User model has a field called password but not one named new_password . With new_password added into _custom_fields , the data bridge class is allowed to declare _bridges_new_password bridge function. _attaching_to is a little more complicated. It should be a tuple of strings, with each string being a name of a field in _bridge_model , indicating that a instance of _bridge_model cannot exist if those fields are empty. For example, if the _attaching_to field is set to (\"a\", \"b\") and if either the data piped to the field a or b is empty, the model instance will hopefully be deleted or at least not exist after bridging.","title":"Bridge Base"},{"location":"backend/data_bridge/base/#bridge-base","text":"This file contains building blocks helping construct data bridge objects. It contains DataBridgeMeta , DataBridgeProtocol , and DataBridgeBase . DataBridgeMeta is a meta class implemented by DataBridgeProtocol . It constructs data bridge subclasses such each subclass will contain a collection of bridge functions , which are functions that validate input and write to the database. The DataBridgeProtocol is a protocol class constructed using the DataBridgeMeta , serving both as a source of attribute types and type reference in other context. The DataBridgeBase inherits DataBridgeProtocol and thus implements DataBridgeMeta . All data bridge classes should inherits DataBridgeBase instead of other bases. Every data bridge class must override the class attribute _bridged_model_cls so that it contains the Django model class as an indication that the the instances of this data bridge class will pipe inputs to that kind of Django model instance. As a result, in the creation process of the data bridge class, DataBridgeMeta serves as its meta class and collects bridge functions , which will be stored in _bridges class variable. DataBridgeMeta also makes sure the naming of bridge functions align with the fields in the model specified in _bridged_model_cls . Bridge functions are like pipes or middleware between API inputs and the database. It validates the input data and safely stores it into the database. Bridge functions should have their name start with the name _bridges_ following with the field name, that is, it follows the format _bridges_<field_name> . For example, _bridges_status is a bridge function operating on the field status . If the <field_name> of some bridge function is not present in Django model, an error will be raised. If some field in the _bridge_model does not have a bridge function, an error will be raised only if programmers try to pipe data to the field through the data bridge to that particular field. The metaclass also wraps each bridge function with a basic permission validator. Whether or not a permission and which level of permission is required should be indicated in the class variable _require_authentication and _minimal_user_role . It's defaulted to be open to everyone. In addition, there is a _custom_fields class attribute and a _attaching_to class attribute. _custom_fields allows bridge functions whose <field_name> is not specified in the corresponding Django model to exist. For example, User model has a field called password but not one named new_password . With new_password added into _custom_fields , the data bridge class is allowed to declare _bridges_new_password bridge function. _attaching_to is a little more complicated. It should be a tuple of strings, with each string being a name of a field in _bridge_model , indicating that a instance of _bridge_model cannot exist if those fields are empty. For example, if the _attaching_to field is set to (\"a\", \"b\") and if either the data piped to the field a or b is empty, the model instance will hopefully be deleted or at least not exist after bridging.","title":"Bridge Base"},{"location":"backend/data_bridge/introduction/","text":"Introduction This folder contains data bridge objects that serve as middleware between database and API queries/mutations. This middleware keeps data safe by checking user permissions and also processes the incoming data to ensure coherence.","title":"Introduction"},{"location":"backend/data_bridge/introduction/#introduction","text":"This folder contains data bridge objects that serve as middleware between database and API queries/mutations. This middleware keeps data safe by checking user permissions and also processes the incoming data to ensure coherence.","title":"Introduction"},{"location":"backend/database/introduction/","text":"Introduction This topic directory concerns the design of the database scheme. The description of each table is named <table_name>_table.md . Without special statements, models.<field_name> refers to django.db.models.<field_name> .","title":"Introduction"},{"location":"backend/database/introduction/#introduction","text":"This topic directory concerns the design of the database scheme. The description of each table is named <table_name>_table.md . Without special statements, models.<field_name> refers to django.db.models.<field_name> .","title":"Introduction"},{"location":"backend/database/mixins/","text":"Mixins This document introduces some of the mixins used by the models in Graphery. All mixins are subclasses of models.Model with the abstract property in its Meta class set to True . For example, from django.db import models class PersonMixin ( models . Model ): name = models . CharField ( _ ( 'name' ), max_length = 255 ) class Meta : abstract = True UUIDMixin The UUIDMixin overrides the original primary key id so that it's a models.UUIDField . Field Type Description id models.UUIDField Overrides the type of the primary key Every model in Graphery must inherit this mixin. That is, every model in Graphery must use UUID as it's primary key. from uuid import uuid4 from django.db import models class UUIDMixin ( models . Model ): id = models . UUIDField ( primary_key = True , default = uuid4 , editable = False ) class Meta : abstract = True TimeDateMixin The TimeDateMixin is used to record the created time and modified time of entries in models inheriting this mixin. It has two fields: Field Type Description created_time models.DateTimeField with auto_now_add option set to True or default option set to timezone.now This records the time of the corresponding entry from some model, when the entry is created. modified_time models.DateTimeField with auto_now option set to True This records the time of the corresponding entry from some model, when the entry is modified. class TimeDateMixin ( models . Model ): created_time = models . DateTimeField ( auto_now_add = True ) modified_time = models . DateTimeField ( auto_now = True ) class Meta : abstract = True PublicManager Additionally, this mixin has it's objects manager overridden. Details will be posted later. Here are some tools developers might need to create a manager: F() expression annotate(args*, **kwargs) related post class PublicManager ( models . Manager ): \"\"\"details coming later\"\"\" def __init__ ( self , * args , ** kwargs ) -> None : def get_public_objects ( self ) -> QuerySet : \"\"\"details coming later\"\"\" pass PublishedMixin (Deprecated) PublishedMixin is used to indicate whether an entry is publicly viewable without privileges. It has a is_published boolean field as the indicator. Additionally, a computed property is_public is provided to developers so that they use other conditions to determine whether an entry can be seen without privileges. is_public should be used, instead of is_published`. Field Type Description is_published models.BooleanField with default set to False This indicates whether an entry is published or not. from django.db import models class PublishedManager ( PublicManager ): def get_public_objects ( self ) -> QuerySet : return self . annotate () class PublishedMixin ( models . Model ): is_published = models . BooleanField ( default = False ) @property def is_public ( self ) -> bool : return self . is_published class Meta : abstract = True StatusMixin StatusMixin is intended to be a replacement for PublishedMixin . In the status mixin, developers can assign statuses other than published and not published , enabling for more flexible access control. Field Type Description item_status models.CharField This field, having a size of 20 chars, indicates the status of an item in the database. The content of the CharIField is restricted to the following status list. Status List The status list shows all the possible status code item_status can have. All the codes are all caps. Status Name Status Code Description draft DRAFT incomplete and only viewable by anyone with proper user role. published PUBLISHED complete and viewable by everyone. reviewing REVIEWING waiting to be published by user with publishing capability. private PRIVATE only viewable by internal staff. trash TRASH trashed. autosave AUTOSAVE autosaved draft closed CLOSED closed draft Additional Argument Variable Name Type Description _default_status str The default status used when no status code is supplied. VersionMixin VersionMixin defines a double linked list to store the versioning information. Status Name Status Code Description back OTO(<itself>) This is used to indicate the previous version. If it's set to None , the current version is the oldest version. front OTO(<itself>) This is used to indicate the next version. If it's set to None , the current version is the newest version. edited_by FK(Users) The person who edited it. LangMixin The LangMixin is intended to indicate what language a database record is written in. Field Type Description lang_code models.CharField The language code","title":"Mixins"},{"location":"backend/database/mixins/#mixins","text":"This document introduces some of the mixins used by the models in Graphery. All mixins are subclasses of models.Model with the abstract property in its Meta class set to True . For example, from django.db import models class PersonMixin ( models . Model ): name = models . CharField ( _ ( 'name' ), max_length = 255 ) class Meta : abstract = True","title":"Mixins"},{"location":"backend/database/mixins/#uuidmixin","text":"The UUIDMixin overrides the original primary key id so that it's a models.UUIDField . Field Type Description id models.UUIDField Overrides the type of the primary key Every model in Graphery must inherit this mixin. That is, every model in Graphery must use UUID as it's primary key. from uuid import uuid4 from django.db import models class UUIDMixin ( models . Model ): id = models . UUIDField ( primary_key = True , default = uuid4 , editable = False ) class Meta : abstract = True","title":"UUIDMixin"},{"location":"backend/database/mixins/#timedatemixin","text":"The TimeDateMixin is used to record the created time and modified time of entries in models inheriting this mixin. It has two fields: Field Type Description created_time models.DateTimeField with auto_now_add option set to True or default option set to timezone.now This records the time of the corresponding entry from some model, when the entry is created. modified_time models.DateTimeField with auto_now option set to True This records the time of the corresponding entry from some model, when the entry is modified. class TimeDateMixin ( models . Model ): created_time = models . DateTimeField ( auto_now_add = True ) modified_time = models . DateTimeField ( auto_now = True ) class Meta : abstract = True","title":"TimeDateMixin"},{"location":"backend/database/mixins/#publicmanager","text":"Additionally, this mixin has it's objects manager overridden. Details will be posted later. Here are some tools developers might need to create a manager: F() expression annotate(args*, **kwargs) related post class PublicManager ( models . Manager ): \"\"\"details coming later\"\"\" def __init__ ( self , * args , ** kwargs ) -> None : def get_public_objects ( self ) -> QuerySet : \"\"\"details coming later\"\"\" pass","title":"PublicManager"},{"location":"backend/database/mixins/#publishedmixin-deprecated","text":"PublishedMixin is used to indicate whether an entry is publicly viewable without privileges. It has a is_published boolean field as the indicator. Additionally, a computed property is_public is provided to developers so that they use other conditions to determine whether an entry can be seen without privileges. is_public should be used, instead of is_published`. Field Type Description is_published models.BooleanField with default set to False This indicates whether an entry is published or not. from django.db import models class PublishedManager ( PublicManager ): def get_public_objects ( self ) -> QuerySet : return self . annotate () class PublishedMixin ( models . Model ): is_published = models . BooleanField ( default = False ) @property def is_public ( self ) -> bool : return self . is_published class Meta : abstract = True","title":"PublishedMixin (Deprecated)"},{"location":"backend/database/mixins/#statusmixin","text":"StatusMixin is intended to be a replacement for PublishedMixin . In the status mixin, developers can assign statuses other than published and not published , enabling for more flexible access control. Field Type Description item_status models.CharField This field, having a size of 20 chars, indicates the status of an item in the database. The content of the CharIField is restricted to the following status list.","title":"StatusMixin"},{"location":"backend/database/mixins/#status-list","text":"The status list shows all the possible status code item_status can have. All the codes are all caps. Status Name Status Code Description draft DRAFT incomplete and only viewable by anyone with proper user role. published PUBLISHED complete and viewable by everyone. reviewing REVIEWING waiting to be published by user with publishing capability. private PRIVATE only viewable by internal staff. trash TRASH trashed. autosave AUTOSAVE autosaved draft closed CLOSED closed draft","title":"Status List"},{"location":"backend/database/mixins/#additional-argument","text":"Variable Name Type Description _default_status str The default status used when no status code is supplied. VersionMixin VersionMixin defines a double linked list to store the versioning information. Status Name Status Code Description back OTO(<itself>) This is used to indicate the previous version. If it's set to None , the current version is the oldest version. front OTO(<itself>) This is used to indicate the next version. If it's set to None , the current version is the newest version. edited_by FK(Users) The person who edited it.","title":"Additional Argument"},{"location":"backend/database/mixins/#langmixin","text":"The LangMixin is intended to indicate what language a database record is written in. Field Type Description lang_code models.CharField The language code","title":"LangMixin"},{"location":"backend/database/tutorial_related_tables/introduction/","text":"Introduction This document explains the terms used in the database classes. Tag Term Description tutorial tag The tags that are used by tutorials. graph tag The tags that are used by graphs. Tutorial Term Description tutorial A tutorial, consisting of four parts: textual content, graphs, code, and code execution result. textual tutorial Also know as the text content of a tutorial tutorial ID The unique UUID of the tutorial. tutorial URL The URL that users use to access the corresponding tutorial content. tutorial anchor a collection of a tutorial's metadata. This includes the tutorial url , tutorial anchor name , tutorial tags , etc. See tutorial_anchor_table.md for more information. tutorial anchor name The name of a tutorial anchor. tutorial tag See tutorial tag above in the Tag section. tutorial translation The translation of a tutorial. This includes the tutorial translation title , tutorial translation authors , tutorial translation abstract , etc. Note that English (the default language of this site) is a special case of tutorial content. See tutorial_translation_table.md and documents for its subclasses for more information. tutorial translation title The title of a tutorial translation tutorial translation author The author of a tutorial translation tutorial translation abstract The abstract of a tutorial translation tutorial translation content The main content of a tutorial translation tutorial translation content markdown The markdown version of a tutorial translation content tutorial translation content html The HTML version of a tutorial translation content Graph Term Description graph anchor a collection of a graph's metadata graph ID The unique UUID of the graph. graph URL The URL that users use to access the corresponding graph. graph name The name of the graph. graph JSON The JSON description of the an actual graph. The format is in CYJS. graph tag Tag associated with this graph. graph maker Maker of the graph JSON. graph source The source of the graph. graph content The descrition of graphs in JSON and other format. This is different than the graph description. See below for more details. graph description The table storing textual descriptionsof a graph, which states what the graph is about, etc. graph description title The title of the graph description graph description content The textual description of a graph tutorial of this graph (TBD) The tutorial that's using this graph. Code Term Description code ID The unique UUID of the code code content The actual texual code tutorial of the code The unique tutorial that talks about the code. Execution Result Term Description execution result ID The unique UUID of a execution result. execution result The execution result of some code on some graph. Uploads Term Description upload URL The unique URL pointing to the uploaded resource. upload ID The unique UUID of the uploaded resource. uploaded content The content that's uploaded as an attachment to the server.","title":"Introduction"},{"location":"backend/database/tutorial_related_tables/introduction/#introduction","text":"This document explains the terms used in the database classes.","title":"Introduction"},{"location":"backend/database/tutorial_related_tables/introduction/#tag","text":"Term Description tutorial tag The tags that are used by tutorials. graph tag The tags that are used by graphs.","title":"Tag"},{"location":"backend/database/tutorial_related_tables/introduction/#tutorial","text":"Term Description tutorial A tutorial, consisting of four parts: textual content, graphs, code, and code execution result. textual tutorial Also know as the text content of a tutorial tutorial ID The unique UUID of the tutorial. tutorial URL The URL that users use to access the corresponding tutorial content. tutorial anchor a collection of a tutorial's metadata. This includes the tutorial url , tutorial anchor name , tutorial tags , etc. See tutorial_anchor_table.md for more information. tutorial anchor name The name of a tutorial anchor. tutorial tag See tutorial tag above in the Tag section. tutorial translation The translation of a tutorial. This includes the tutorial translation title , tutorial translation authors , tutorial translation abstract , etc. Note that English (the default language of this site) is a special case of tutorial content. See tutorial_translation_table.md and documents for its subclasses for more information. tutorial translation title The title of a tutorial translation tutorial translation author The author of a tutorial translation tutorial translation abstract The abstract of a tutorial translation tutorial translation content The main content of a tutorial translation tutorial translation content markdown The markdown version of a tutorial translation content tutorial translation content html The HTML version of a tutorial translation content","title":"Tutorial"},{"location":"backend/database/tutorial_related_tables/introduction/#graph","text":"Term Description graph anchor a collection of a graph's metadata graph ID The unique UUID of the graph. graph URL The URL that users use to access the corresponding graph. graph name The name of the graph. graph JSON The JSON description of the an actual graph. The format is in CYJS. graph tag Tag associated with this graph. graph maker Maker of the graph JSON. graph source The source of the graph. graph content The descrition of graphs in JSON and other format. This is different than the graph description. See below for more details. graph description The table storing textual descriptionsof a graph, which states what the graph is about, etc. graph description title The title of the graph description graph description content The textual description of a graph tutorial of this graph (TBD) The tutorial that's using this graph.","title":"Graph"},{"location":"backend/database/tutorial_related_tables/introduction/#code","text":"Term Description code ID The unique UUID of the code code content The actual texual code tutorial of the code The unique tutorial that talks about the code.","title":"Code"},{"location":"backend/database/tutorial_related_tables/introduction/#execution-result","text":"Term Description execution result ID The unique UUID of a execution result. execution result The execution result of some code on some graph.","title":"Execution Result"},{"location":"backend/database/tutorial_related_tables/introduction/#uploads","text":"Term Description upload URL The unique URL pointing to the uploaded resource. upload ID The unique UUID of the uploaded resource. uploaded content The content that's uploaded as an attachment to the server.","title":"Uploads"},{"location":"backend/database/tutorial_related_tables/code/code_table/","text":"Code Table The Code table describes runnable code snippets. Mixins UUIDMixin TimeDateMixin Fields Field Type Description name models.TextField The human readable name for this code snippet code models.TextField The code snippet tutorial_anchor OTO(TutorialAnchor) The tutorial associated with this code snippet Code Snippet Guidelines This describes behaviors of code acceptable by 3.0 API. For 2.0 API, please consult the older document. After the 3.0 API, the graph and network library networkx are injected automatically as nx and networkx , and users can use it directly, so there is no need to import additional graph or library. With that said, following header should be appended to every code, in which graph variable is stated in the environment, and the upcoming code should only use graph to refer to the tutorial graph. This is because users can apply the tutorial algorithms by coping the whole tutorial code and replacing graph with any other networkx graph, without changing anything else. UPDATE : The following header and tail will not be added but rather written manually. # Python Version: <the python version of the executor> # Executor Version: <the version of the executor> from __future__ import annotations import networkx as nx graph : nx . Graph # graph is injected automatically and refers to the tutorial graph Due to the structural change of the executor, the \"main\" entrance must be stated in the end for a code to be executed. For example: if __name__ == '__main__' : # do something here pass The header should not appear in the database, but rather added during the runtime request. That is, suppose the algorithm looks like the following def main (): # an algorithm for looping through all the code for node in graph . nodes : print ( node ) The code displayed in the frontend should be # Python Version: <the python version of the executor> # Executor Version: <the version of the executor> from __future__ import annotations import networkx as nx graph : nx . Graph # graph is injected automatically and refers to the tutorial graph def main (): # an algorithm for looping through all the code for node in graph . nodes : print ( node ) if __name__ == '__main__' : # do something here main () All the code will be lint with black in the backend before being stored into the database.","title":"`Code` Table"},{"location":"backend/database/tutorial_related_tables/code/code_table/#code-table","text":"The Code table describes runnable code snippets.","title":"Code Table"},{"location":"backend/database/tutorial_related_tables/code/code_table/#mixins","text":"UUIDMixin TimeDateMixin","title":"Mixins"},{"location":"backend/database/tutorial_related_tables/code/code_table/#fields","text":"Field Type Description name models.TextField The human readable name for this code snippet code models.TextField The code snippet tutorial_anchor OTO(TutorialAnchor) The tutorial associated with this code snippet","title":"Fields"},{"location":"backend/database/tutorial_related_tables/code/code_table/#code-snippet-guidelines","text":"This describes behaviors of code acceptable by 3.0 API. For 2.0 API, please consult the older document. After the 3.0 API, the graph and network library networkx are injected automatically as nx and networkx , and users can use it directly, so there is no need to import additional graph or library. With that said, following header should be appended to every code, in which graph variable is stated in the environment, and the upcoming code should only use graph to refer to the tutorial graph. This is because users can apply the tutorial algorithms by coping the whole tutorial code and replacing graph with any other networkx graph, without changing anything else. UPDATE : The following header and tail will not be added but rather written manually. # Python Version: <the python version of the executor> # Executor Version: <the version of the executor> from __future__ import annotations import networkx as nx graph : nx . Graph # graph is injected automatically and refers to the tutorial graph Due to the structural change of the executor, the \"main\" entrance must be stated in the end for a code to be executed. For example: if __name__ == '__main__' : # do something here pass The header should not appear in the database, but rather added during the runtime request. That is, suppose the algorithm looks like the following def main (): # an algorithm for looping through all the code for node in graph . nodes : print ( node ) The code displayed in the frontend should be # Python Version: <the python version of the executor> # Executor Version: <the version of the executor> from __future__ import annotations import networkx as nx graph : nx . Graph # graph is injected automatically and refers to the tutorial graph def main (): # an algorithm for looping through all the code for node in graph . nodes : print ( node ) if __name__ == '__main__' : # do something here main () All the code will be lint with black in the backend before being stored into the database.","title":"Code Snippet Guidelines"},{"location":"backend/database/tutorial_related_tables/execution_result/execution_result_table/","text":"ExecutionResult Table The ExecutionResult table contains the execution results. Each of the result is specified by a code snippet and a graph. The execution JSON has to be formatted in a special configuration. Mixins UUIDMixin TimeDateMixin Fields Field Type Description code FK(Code) graph FK(GraphAnchor) result_json models.JSONField result_json_meta models.JSONField Result JSON API See here . Result JSON Meta API See here .","title":"`ExecutionResult` Table"},{"location":"backend/database/tutorial_related_tables/execution_result/execution_result_table/#executionresult-table","text":"The ExecutionResult table contains the execution results. Each of the result is specified by a code snippet and a graph. The execution JSON has to be formatted in a special configuration.","title":"ExecutionResult Table"},{"location":"backend/database/tutorial_related_tables/execution_result/execution_result_table/#mixins","text":"UUIDMixin TimeDateMixin","title":"Mixins"},{"location":"backend/database/tutorial_related_tables/execution_result/execution_result_table/#fields","text":"Field Type Description code FK(Code) graph FK(GraphAnchor) result_json models.JSONField result_json_meta models.JSONField","title":"Fields"},{"location":"backend/database/tutorial_related_tables/execution_result/execution_result_table/#result-json-api","text":"See here .","title":"Result JSON API"},{"location":"backend/database/tutorial_related_tables/execution_result/execution_result_table/#result-json-meta-api","text":"See here .","title":"Result JSON Meta API"},{"location":"backend/database/tutorial_related_tables/execution_result/result_json_api/","text":"Result JSON API API versions 3.0 2.0 1.0(Depricated) 3.0 API Credit: a lot of internal changes were inspired by PyTutor . type graph_object_type = \"Node\" | \"Edge\" | \"DataEdge\" | \"MultiEdge\" | \"MultiDataEdge\" ; type python_object_type = | \"Number\" | \"String\" | \"List\" | \"Tuple\" | \"Deque\" | \"None\" | \"Set\" | \"Mapping\" | \"Sequence\" | \"Object\" ; type special_object_type = \"Init\" | \"Ref\" ; type object_type = | graph_object_type | python_object_type | special_object_type ; type object_identity_seperator = \"\\u200b@\" ; type object_identity_type = ` ${ string }${ object_identity_seperator }${ string } ` ; interface compositional_object_identity_type { type : object_type ; color : string ; repr : string ; properties ?: { graph_id : string ; [ key : string ] : string | number ; }; python_id : number ; } interface record_type { line : number ; variables : Record < object_identity_type , compositional_object_identity_type > ; accesses? : compositional_object_identity_type []; variable_orders? : string []; stdout? : string []; } type record_array_type = record_type []; Examples: let an_example : compositional_object_identity_type = { type : \"Node\" , color : \"#3A5F99\" , repr : \"animal node\" , properties : { graph_id : \"#19\" , degree : 19 , }, python_id : 4411533616 , }; let snd_example : compositional_object_identity_type = { type : \"Number\" , color : \"#334766\" , repr : \"20\" , python_id : 4411533616 , }; let one_more_example : record_type = { line : 18 , variables : { \"main\\u200b@test_var\" : an_example , }, accesses : [ snd_example ], stdout : [ \"hello world!\" ], }; 2.0 API A record array looks like this. Each element in the record array is called record object or simply record . record_array = [ { 'line' : 18 , 'variables' : { '<identity>' : { 'type' : 'some_type' , 'color' : 'some_color_hex' , 'repr' : 'some_repr' , 'id' : 'graph_element_id' , 'properties' : { 'property_1' : str or number , ... }, \"python_id\" : 123456789 } }, 'accesses' : [ { 'type' : 'some_type' , 'color' : 'some_color_hex' , 'repr' : 'some_repr' , 'properties' : { 'property_1' : str or number , ... }, \"python_id\" : 123456789 }, ], 'order' : [ 'identity1' , 'identity2' , ... ] }, ... ] line The line field indicates which line this object is referencing. The type is int . variables The variables field indicates which variables are accessed in this line. It's a dict type, or object in JS. The members are detailed below. <identity> The <identity> is going to be replaced by a string built from an Sequence of strings by the following rules. First, we need a ideantity Sequence , which has a length greater than 2 to avoid namespace collision. For example, a tuple ('test_function', 'test_var') . One with length greater than 2 is also acceptable, as long as the frontend and the backend agree. The length is probably going to get longer to cope with potential name duplication, since by adding more string we are creating new namespaces. The last item of the Sequence must be the name of the variable, which is to be displayed on the screen. This must be reinforced by both the frontend and the backend. When the elements in the Sequence are connected by a separator, they become a textual variable identity , which is going to replace the <identity> 's place. The separator is now proposed to be u'\\u200b@' , where u'\\u200b' is an empty char that's almost impossible to appear in the domain of possible components and u'@' is to make sure it's human readable during debugging. The <identity> should be decoded in the following way by removing the separator in a textual variable identity. Two <identity> s are considered as the same when they have the same namespaces and the same name For future discussions, the content in a <identity> field, ie. the object of <identity> , is called compositional variable identity . type The type should be a enum(mapping) that has the following values. { Node : 'Node' , Edge : 'Edge' , str : 'String' , List : 'List' , Tuple : 'Tuple' , Deque : 'Deque' , # Counter: 'Counter', type ( None ): 'None' , Set : 'Set' , # which includes Set, set, KeyView(dict_keys), ItemView(dict_items), frozenset, MutableSet Mapping : 'Mapping' , # which includes mappingproxy (not sure what that is), MutableMapping, dict Sequence : 'Sequence' , # which includes tuple, str, range, memoryview, MutableSequence, list, bytearray # ByteString: 'ByteString', # which is optional in this version object : 'Object' # the wildcard that matches everything else } Some additional types are added to provide more information: [ 'init' , 'reference' , ] init type indicates the element has not been initialized yet, which should only be used on the variables in the first record. reference type indicates the current object is a reference, and guarantees that the object appears in the previous stack trace. To obtain the detail of the object, the program should look backward. (we will talk about this later) The type string should follow the naming convention of a Python class. The order in this dictionary matters. Since if a string ( str type) is matched as a sequence ( Sequence type), the frontend is probably going to unfold the elements (in this case the chars, so a literal hello will be displayed as [H, E, L, L, O] ). The types can be further divided into subcategories: _SINGULAR_MAPPING = { Number : 'Number' , str : 'String' , Node : 'Node' , Edge : 'Edge' , type ( None ): 'None' , } # and _LINEAR_CONTAINER_MAPPING = { List : 'List' , Tuple : 'Tuple' , Deque : 'Deque' , Set : 'Set' , # which includes Set, set, KeyView(dict_keys), ValueView(dict_values), ItemView(dict_items), # frozenset, MutableSet Sequence : 'Sequence' , # which includes tuple, str, range, memoryview, MutableSequence, list, bytearray } # and _PAIR_CONTAINER_MAPPING = { Counter : 'Counter' , Mapping : 'Mapping' , # which includes mappingproxy (not sure what that is), MutableMapping, dict } # and _WILDCARD_MAPPING = { object : 'Object' } # so _TYPE_MAPPING = { # simple individuals ** _SINGULAR_MAPPING , # simple linear containers ** _LINEAR_CONTAINER_MAPPING , # simple pair containers ** _PAIR_CONTAINER_MAPPING , # wildcard ** _WILDCARD_MAPPING } repr Types in the singular mapping should be checked first. And they will be converted into strings when being as the value of repr field. For types in the linear container mapping, we are using recursive resolution method for the elements in the object, meaning the every memeber in a linear container will go through the resolution function again. The repr field of the objects of these types will be a array of compositional variable identities. Since JSON doesn't support keys being objects, objects in the pair container cannot be represented in key-value pair as they do in the python. So the elements, contents of both key and value in the key-value pair, in objects of these types will also go through recursive resolution. As a result, we are using an array to represent the key-value pairs in each pair container. The repr field will be a array of objects with object having only two key-value pairs, whose keys are key and value respectively, and values are compositional variable identities. Here is an example: # for linear containers [ { \"type\" : \"some_type\" , \"color\" : \"some_color_hex\" , \"repr\" : \"some_repr\" , \"id\" : \"graph_element_id\" , \"properties\" : { \"property_1\" : \"str or number\" ... }, # (required only by graph objects like nodes and edges) \"python_id\" : 123456789 }, { \"type\" : \"some_type\" , \"color\" : \"some_color_hex\" , \"repr\" : \"some_repr\" , \"id\" : \"graph_element_id\" , \"properties\" : { \"property_1\" : \"str or number\" ... }, \"python_id\" : 123456789 } ] # for pair containers [ { \"key\" : { \"type\" : \"some_type\" , \"color\" : \"some_color_hex\" , \"repr\" : \"some_repr\" , \"id\" : \"graph_element_id\" , \"properties\" : { \"property_1\" : \"str or number\" ... }, \"python_id\" : 123456789 }, \"value\" : { \"type\" : \"some_type\" , \"color\" : \"some_color_hex\" , \"repr\" : \"some_repr\" , \"id\" : \"graph_element_id\" , \"properties\" : { \"property_1\" : \"str or number\" ... }, \"python_id\" : 123456789 } }, ... ] Hence, we can preserve the key-value pairs and use recursion to generate general object representations. repr should be a string representation of the value. The repr should be formatted according to the type field. Then, if the __repr__ or __str__ function is overridden in a instance, the program should use those. It should prefer __repr__ over __str__ . Otherwise, the ugly default representation should be used. color The color is used to in the visualization. The value of color must be a string of hex color. The hex color should be chose in a way that's friendly to color blind people. It's not guaranteed that all colors are friendly. The author should try to expand the palette as much as possible. id The field id is the id of the graph element. The field facilitates the interaction with and is required by the Cytoscape module. property (only bounded to graph objects like nodes and edges) The item is property which is a graph-element-specific item. That is, only graph elements have this item. The property contains the properties that's needed to be displayed on the tooltips in the Cytoscape window. Currently, the value of the property mapping should only be a string or a number. python_id The python_id field is to collect the result of id() of the object. When there is a recursive structure, the repeated objects can refer to the previous object. accesses The accesses contains a list of accessed values from some function calls. If a function is marked with a decorator look_at , the return value of the function will be recorded. The new variable list is going to bring up the changed variables. So order is a new field that going to specify the order of the variables on the variable list. Since the dictionary used in the variable list preserves the insertion order, one way to get around order field is by deleting the variable and add it back as if it's a new record. 1.0 API (Depricated) record_array = [ { 'line' : 17 , 'variables' : { 'identity' : { 'type' : 'some_type' , 'color' : 'some_color_hex' , 'repr' : 'some_repr' } } }, ... ] The line variable is the line number of current execution. Say the current line is 17, the variables are showing the list of variable in the environment after the line is executed. identity is built from (prefix, variable_name) . The prefix is the string representation of a class or a function. The variable name is the variable name of the variable. This format is going to create namespace for every variable and avoid errors on frontend parsing. The identity itself is a string. The two components are separated by # . type is an after-thought added at the end of the first development cycle. This was intended to distinguish graph objects from regular objects. color is the color hex with which the variable is going to be identified on the frontend. repr is the string representation of the variable, that is, the value of the variable.","title":"Result JSON API"},{"location":"backend/database/tutorial_related_tables/execution_result/result_json_api/#result-json-api","text":"","title":"Result JSON API"},{"location":"backend/database/tutorial_related_tables/execution_result/result_json_api/#api-versions","text":"3.0 2.0 1.0(Depricated)","title":"API versions"},{"location":"backend/database/tutorial_related_tables/execution_result/result_json_api/#3-0","text":"Credit: a lot of internal changes were inspired by PyTutor . type graph_object_type = \"Node\" | \"Edge\" | \"DataEdge\" | \"MultiEdge\" | \"MultiDataEdge\" ; type python_object_type = | \"Number\" | \"String\" | \"List\" | \"Tuple\" | \"Deque\" | \"None\" | \"Set\" | \"Mapping\" | \"Sequence\" | \"Object\" ; type special_object_type = \"Init\" | \"Ref\" ; type object_type = | graph_object_type | python_object_type | special_object_type ; type object_identity_seperator = \"\\u200b@\" ; type object_identity_type = ` ${ string }${ object_identity_seperator }${ string } ` ; interface compositional_object_identity_type { type : object_type ; color : string ; repr : string ; properties ?: { graph_id : string ; [ key : string ] : string | number ; }; python_id : number ; } interface record_type { line : number ; variables : Record < object_identity_type , compositional_object_identity_type > ; accesses? : compositional_object_identity_type []; variable_orders? : string []; stdout? : string []; } type record_array_type = record_type []; Examples: let an_example : compositional_object_identity_type = { type : \"Node\" , color : \"#3A5F99\" , repr : \"animal node\" , properties : { graph_id : \"#19\" , degree : 19 , }, python_id : 4411533616 , }; let snd_example : compositional_object_identity_type = { type : \"Number\" , color : \"#334766\" , repr : \"20\" , python_id : 4411533616 , }; let one_more_example : record_type = { line : 18 , variables : { \"main\\u200b@test_var\" : an_example , }, accesses : [ snd_example ], stdout : [ \"hello world!\" ], };","title":"3.0 API"},{"location":"backend/database/tutorial_related_tables/execution_result/result_json_api/#2-0","text":"A record array looks like this. Each element in the record array is called record object or simply record . record_array = [ { 'line' : 18 , 'variables' : { '<identity>' : { 'type' : 'some_type' , 'color' : 'some_color_hex' , 'repr' : 'some_repr' , 'id' : 'graph_element_id' , 'properties' : { 'property_1' : str or number , ... }, \"python_id\" : 123456789 } }, 'accesses' : [ { 'type' : 'some_type' , 'color' : 'some_color_hex' , 'repr' : 'some_repr' , 'properties' : { 'property_1' : str or number , ... }, \"python_id\" : 123456789 }, ], 'order' : [ 'identity1' , 'identity2' , ... ] }, ... ]","title":"2.0 API"},{"location":"backend/database/tutorial_related_tables/execution_result/result_json_api/#line","text":"The line field indicates which line this object is referencing. The type is int .","title":"line"},{"location":"backend/database/tutorial_related_tables/execution_result/result_json_api/#variables","text":"The variables field indicates which variables are accessed in this line. It's a dict type, or object in JS. The members are detailed below.","title":"variables"},{"location":"backend/database/tutorial_related_tables/execution_result/result_json_api/#identity","text":"The <identity> is going to be replaced by a string built from an Sequence of strings by the following rules. First, we need a ideantity Sequence , which has a length greater than 2 to avoid namespace collision. For example, a tuple ('test_function', 'test_var') . One with length greater than 2 is also acceptable, as long as the frontend and the backend agree. The length is probably going to get longer to cope with potential name duplication, since by adding more string we are creating new namespaces. The last item of the Sequence must be the name of the variable, which is to be displayed on the screen. This must be reinforced by both the frontend and the backend. When the elements in the Sequence are connected by a separator, they become a textual variable identity , which is going to replace the <identity> 's place. The separator is now proposed to be u'\\u200b@' , where u'\\u200b' is an empty char that's almost impossible to appear in the domain of possible components and u'@' is to make sure it's human readable during debugging. The <identity> should be decoded in the following way by removing the separator in a textual variable identity. Two <identity> s are considered as the same when they have the same namespaces and the same name For future discussions, the content in a <identity> field, ie. the object of <identity> , is called compositional variable identity .","title":"&lt;identity&gt;"},{"location":"backend/database/tutorial_related_tables/execution_result/result_json_api/#type","text":"The type should be a enum(mapping) that has the following values. { Node : 'Node' , Edge : 'Edge' , str : 'String' , List : 'List' , Tuple : 'Tuple' , Deque : 'Deque' , # Counter: 'Counter', type ( None ): 'None' , Set : 'Set' , # which includes Set, set, KeyView(dict_keys), ItemView(dict_items), frozenset, MutableSet Mapping : 'Mapping' , # which includes mappingproxy (not sure what that is), MutableMapping, dict Sequence : 'Sequence' , # which includes tuple, str, range, memoryview, MutableSequence, list, bytearray # ByteString: 'ByteString', # which is optional in this version object : 'Object' # the wildcard that matches everything else } Some additional types are added to provide more information: [ 'init' , 'reference' , ] init type indicates the element has not been initialized yet, which should only be used on the variables in the first record. reference type indicates the current object is a reference, and guarantees that the object appears in the previous stack trace. To obtain the detail of the object, the program should look backward. (we will talk about this later) The type string should follow the naming convention of a Python class. The order in this dictionary matters. Since if a string ( str type) is matched as a sequence ( Sequence type), the frontend is probably going to unfold the elements (in this case the chars, so a literal hello will be displayed as [H, E, L, L, O] ). The types can be further divided into subcategories: _SINGULAR_MAPPING = { Number : 'Number' , str : 'String' , Node : 'Node' , Edge : 'Edge' , type ( None ): 'None' , } # and _LINEAR_CONTAINER_MAPPING = { List : 'List' , Tuple : 'Tuple' , Deque : 'Deque' , Set : 'Set' , # which includes Set, set, KeyView(dict_keys), ValueView(dict_values), ItemView(dict_items), # frozenset, MutableSet Sequence : 'Sequence' , # which includes tuple, str, range, memoryview, MutableSequence, list, bytearray } # and _PAIR_CONTAINER_MAPPING = { Counter : 'Counter' , Mapping : 'Mapping' , # which includes mappingproxy (not sure what that is), MutableMapping, dict } # and _WILDCARD_MAPPING = { object : 'Object' } # so _TYPE_MAPPING = { # simple individuals ** _SINGULAR_MAPPING , # simple linear containers ** _LINEAR_CONTAINER_MAPPING , # simple pair containers ** _PAIR_CONTAINER_MAPPING , # wildcard ** _WILDCARD_MAPPING }","title":"type"},{"location":"backend/database/tutorial_related_tables/execution_result/result_json_api/#repr","text":"Types in the singular mapping should be checked first. And they will be converted into strings when being as the value of repr field. For types in the linear container mapping, we are using recursive resolution method for the elements in the object, meaning the every memeber in a linear container will go through the resolution function again. The repr field of the objects of these types will be a array of compositional variable identities. Since JSON doesn't support keys being objects, objects in the pair container cannot be represented in key-value pair as they do in the python. So the elements, contents of both key and value in the key-value pair, in objects of these types will also go through recursive resolution. As a result, we are using an array to represent the key-value pairs in each pair container. The repr field will be a array of objects with object having only two key-value pairs, whose keys are key and value respectively, and values are compositional variable identities. Here is an example: # for linear containers [ { \"type\" : \"some_type\" , \"color\" : \"some_color_hex\" , \"repr\" : \"some_repr\" , \"id\" : \"graph_element_id\" , \"properties\" : { \"property_1\" : \"str or number\" ... }, # (required only by graph objects like nodes and edges) \"python_id\" : 123456789 }, { \"type\" : \"some_type\" , \"color\" : \"some_color_hex\" , \"repr\" : \"some_repr\" , \"id\" : \"graph_element_id\" , \"properties\" : { \"property_1\" : \"str or number\" ... }, \"python_id\" : 123456789 } ] # for pair containers [ { \"key\" : { \"type\" : \"some_type\" , \"color\" : \"some_color_hex\" , \"repr\" : \"some_repr\" , \"id\" : \"graph_element_id\" , \"properties\" : { \"property_1\" : \"str or number\" ... }, \"python_id\" : 123456789 }, \"value\" : { \"type\" : \"some_type\" , \"color\" : \"some_color_hex\" , \"repr\" : \"some_repr\" , \"id\" : \"graph_element_id\" , \"properties\" : { \"property_1\" : \"str or number\" ... }, \"python_id\" : 123456789 } }, ... ] Hence, we can preserve the key-value pairs and use recursion to generate general object representations. repr should be a string representation of the value. The repr should be formatted according to the type field. Then, if the __repr__ or __str__ function is overridden in a instance, the program should use those. It should prefer __repr__ over __str__ . Otherwise, the ugly default representation should be used.","title":"repr"},{"location":"backend/database/tutorial_related_tables/execution_result/result_json_api/#color","text":"The color is used to in the visualization. The value of color must be a string of hex color. The hex color should be chose in a way that's friendly to color blind people. It's not guaranteed that all colors are friendly. The author should try to expand the palette as much as possible.","title":"color"},{"location":"backend/database/tutorial_related_tables/execution_result/result_json_api/#id","text":"The field id is the id of the graph element. The field facilitates the interaction with and is required by the Cytoscape module.","title":"id"},{"location":"backend/database/tutorial_related_tables/execution_result/result_json_api/#property-only-bounded-to-graph-objects-like-nodes-and-edges","text":"The item is property which is a graph-element-specific item. That is, only graph elements have this item. The property contains the properties that's needed to be displayed on the tooltips in the Cytoscape window. Currently, the value of the property mapping should only be a string or a number.","title":"property (only bounded to graph objects like nodes and edges)"},{"location":"backend/database/tutorial_related_tables/execution_result/result_json_api/#python_id","text":"The python_id field is to collect the result of id() of the object. When there is a recursive structure, the repeated objects can refer to the previous object.","title":"python_id"},{"location":"backend/database/tutorial_related_tables/execution_result/result_json_api/#accesses","text":"The accesses contains a list of accessed values from some function calls. If a function is marked with a decorator look_at , the return value of the function will be recorded. The new variable list is going to bring up the changed variables. So order is a new field that going to specify the order of the variables on the variable list. Since the dictionary used in the variable list preserves the insertion order, one way to get around order field is by deleting the variable and add it back as if it's a new record.","title":"accesses"},{"location":"backend/database/tutorial_related_tables/execution_result/result_json_api/#1-0","text":"record_array = [ { 'line' : 17 , 'variables' : { 'identity' : { 'type' : 'some_type' , 'color' : 'some_color_hex' , 'repr' : 'some_repr' } } }, ... ] The line variable is the line number of current execution. Say the current line is 17, the variables are showing the list of variable in the environment after the line is executed. identity is built from (prefix, variable_name) . The prefix is the string representation of a class or a function. The variable name is the variable name of the variable. This format is going to create namespace for every variable and avoid errors on frontend parsing. The identity itself is a string. The two components are separated by # . type is an after-thought added at the end of the first development cycle. This was intended to distinguish graph objects from regular objects. color is the color hex with which the variable is going to be identified on the frontend. repr is the string representation of the variable, that is, the value of the variable.","title":"1.0 API (Depricated)"},{"location":"backend/database/tutorial_related_tables/execution_result/result_json_api/#_1","text":"","title":""},{"location":"backend/database/tutorial_related_tables/execution_result/result_json_meta_api/","text":"Result JSON Meta API API Versions 3.0 3.0 API interface breakpoints_type { [ key : number ] : string ; // the key is the line number // the value is the corresponding tag } interface result_json_meta_type { version : string ; breakpoints : breakpoints_type ; }","title":"Result JSON Meta API"},{"location":"backend/database/tutorial_related_tables/execution_result/result_json_meta_api/#result-json-meta-api","text":"","title":"Result JSON Meta API"},{"location":"backend/database/tutorial_related_tables/execution_result/result_json_meta_api/#api-versions","text":"3.0","title":"API Versions"},{"location":"backend/database/tutorial_related_tables/execution_result/result_json_meta_api/#3-0","text":"interface breakpoints_type { [ key : number ] : string ; // the key is the line number // the value is the corresponding tag } interface result_json_meta_type { version : string ; breakpoints : breakpoints_type ; }","title":"3.0 API"},{"location":"backend/database/tutorial_related_tables/graph/graph_anchor_table/","text":"GraphAnchor Table The GraphAnchor is used to store all the graphs' metadata. This class is very similar to TutorialAnchor class. Mixins UUIDMixin TimeDateMixin StatusMixin Fields Field Type Description url models.CharField The unique URL pointing to the corresponding graph. anchor_name models.TextField The unique name for this anchor. tags MTM(Tag) The graph tags associated with this anchor.","title":"`GraphAnchor` Table"},{"location":"backend/database/tutorial_related_tables/graph/graph_anchor_table/#graphanchor-table","text":"The GraphAnchor is used to store all the graphs' metadata. This class is very similar to TutorialAnchor class.","title":"GraphAnchor Table"},{"location":"backend/database/tutorial_related_tables/graph/graph_anchor_table/#mixins","text":"UUIDMixin TimeDateMixin StatusMixin","title":"Mixins"},{"location":"backend/database/tutorial_related_tables/graph/graph_anchor_table/#fields","text":"Field Type Description url models.CharField The unique URL pointing to the corresponding graph. anchor_name models.TextField The unique name for this anchor. tags MTM(Tag) The graph tags associated with this anchor.","title":"Fields"},{"location":"backend/database/tutorial_related_tables/graph/graph_content_table/","text":"GraphContent Table The GraphContent table stores abstract descriptions of graphs in JSON and other format, if applicable. This is different than the textual description of graphs. See the term explanation for more details. Mixins UUIDMixin TimeDateMixin StatusMixin (Note: the _default_status is set to PUBLISHED ) Fields Field Type Desciption graph_anchor OTO(GraphAnchor) The graph meta data of this graph. makers MTM(User) The makers of this graph cyjs models.JSONField graph description in cyjs format. weighted models.BooleanField Indicate if the graph is weighted or not directed models.BooleanField Indicate if the graph is directed or not","title":"`GraphContent` Table"},{"location":"backend/database/tutorial_related_tables/graph/graph_content_table/#graphcontent-table","text":"The GraphContent table stores abstract descriptions of graphs in JSON and other format, if applicable. This is different than the textual description of graphs. See the term explanation for more details.","title":"GraphContent Table"},{"location":"backend/database/tutorial_related_tables/graph/graph_content_table/#mixins","text":"UUIDMixin TimeDateMixin StatusMixin (Note: the _default_status is set to PUBLISHED )","title":"Mixins"},{"location":"backend/database/tutorial_related_tables/graph/graph_content_table/#fields","text":"Field Type Desciption graph_anchor OTO(GraphAnchor) The graph meta data of this graph. makers MTM(User) The makers of this graph cyjs models.JSONField graph description in cyjs format. weighted models.BooleanField Indicate if the graph is weighted or not directed models.BooleanField Indicate if the graph is directed or not","title":"Fields"},{"location":"backend/database/tutorial_related_tables/graph/graph_description_table/","text":"`GraphDescription Table The GraphDescriptionBase table is similar to TutorialTranslationBase and contains entries that describe what each graph is about. Mixins UUIDMixin TimeDateMixin StatusMixin VersionMixin LangMixin Fields Fields Type Description graph_anchor FK(GraphAnchor) The graph associated with this translation. authors MTM(User) The authors of this description. title models.TextField The title of the description. description models.TextField The description content.","title":"`GraphDescription Table"},{"location":"backend/database/tutorial_related_tables/graph/graph_description_table/#graphdescription-table","text":"The GraphDescriptionBase table is similar to TutorialTranslationBase and contains entries that describe what each graph is about.","title":"`GraphDescription Table"},{"location":"backend/database/tutorial_related_tables/graph/graph_description_table/#mixins","text":"UUIDMixin TimeDateMixin StatusMixin VersionMixin LangMixin","title":"Mixins"},{"location":"backend/database/tutorial_related_tables/graph/graph_description_table/#fields","text":"Fields Type Description graph_anchor FK(GraphAnchor) The graph associated with this translation. authors MTM(User) The authors of this description. title models.TextField The title of the description. description models.TextField The description content.","title":"Fields"},{"location":"backend/database/tutorial_related_tables/tag/tag_anchor_table/","text":"TagAnchor Table The tag anchor table stores tags' anchor points. Graph anchors and tutorial anchors share the same anchor table. Mixins UUIDMixin TimeDateMixin StatusMixin Field Type Description anchor_name models.CharField The name of the anchor.","title":"`TagAnchor` Table"},{"location":"backend/database/tutorial_related_tables/tag/tag_anchor_table/#taganchor-table","text":"The tag anchor table stores tags' anchor points. Graph anchors and tutorial anchors share the same anchor table.","title":"TagAnchor Table"},{"location":"backend/database/tutorial_related_tables/tag/tag_anchor_table/#mixins","text":"UUIDMixin TimeDateMixin StatusMixin Field Type Description anchor_name models.CharField The name of the anchor.","title":"Mixins"},{"location":"backend/database/tutorial_related_tables/tag/tag_table/","text":"Tag Table Tag is a concrete tag model referenced by both TutorialAnchor and GraphAnchor . Mixins UUIDMixin TimeDateMixin Field Type Description name models.CharField The name of the tag, shown to the public. tag_anchor FK(TagAnchor) The anchor point of the tag. description models.TextField The description of this tag.","title":"`Tag` Table"},{"location":"backend/database/tutorial_related_tables/tag/tag_table/#tag-table","text":"Tag is a concrete tag model referenced by both TutorialAnchor and GraphAnchor .","title":"Tag Table"},{"location":"backend/database/tutorial_related_tables/tag/tag_table/#mixins","text":"UUIDMixin TimeDateMixin Field Type Description name models.CharField The name of the tag, shown to the public. tag_anchor FK(TagAnchor) The anchor point of the tag. description models.TextField The description of this tag.","title":"Mixins"},{"location":"backend/database/tutorial_related_tables/tutorial/tutorial_anchor_table/","text":"TutorialAnchor Table A tutorial anchor serves as an entry point to every tutorial, since it contains a unique URL from which users can access the tutorial content. The anchor may contain other useful metadata. Mixins UUIDMixin TimeDateMixin StatusMixin Fields Field Type Description url models.CharField The unique URL pointing to the corresponding tutorial content. anchor_name models.TextField The unique name for this anchor. tags MTM(Tag) The tutorial tags associated with this anchor.","title":"`TutorialAnchor` Table"},{"location":"backend/database/tutorial_related_tables/tutorial/tutorial_anchor_table/#tutorialanchor-table","text":"A tutorial anchor serves as an entry point to every tutorial, since it contains a unique URL from which users can access the tutorial content. The anchor may contain other useful metadata.","title":"TutorialAnchor Table"},{"location":"backend/database/tutorial_related_tables/tutorial/tutorial_anchor_table/#mixins","text":"UUIDMixin TimeDateMixin StatusMixin","title":"Mixins"},{"location":"backend/database/tutorial_related_tables/tutorial/tutorial_anchor_table/#fields","text":"Field Type Description url models.CharField The unique URL pointing to the corresponding tutorial content. anchor_name models.TextField The unique name for this anchor. tags MTM(Tag) The tutorial tags associated with this anchor.","title":"Fields"},{"location":"backend/database/tutorial_related_tables/tutorial/tutorial_table/","text":"`` Table Every entry in TutorialTranslationBase is linked to one anchor and is the one that's actually holding the textual tutorial . The basic structure of the text content contains a title, paragraphs of actual text in markdown version and html version, an abstract of the main text. It also contains metadata like the authors of the text. Mixins UUIDMixin TimeDateMixin StatusMixin VersionMixin LangMixin Fields Field Type Description tutorial_anchor FK(TutorialAnchor) The anchor point of this tutorial. authors MTM(User) A list of authors. title models.TextField The title of this tutorial (translated). abstract models.TextField The abstract of this tutorial (translated). content_md models.TextField The content of this tutorial in Markdown (translated) content_html models.TextField The parsed html of the Markdown tutorial (translated)","title":"`` Table"},{"location":"backend/database/tutorial_related_tables/tutorial/tutorial_table/#table","text":"Every entry in TutorialTranslationBase is linked to one anchor and is the one that's actually holding the textual tutorial . The basic structure of the text content contains a title, paragraphs of actual text in markdown version and html version, an abstract of the main text. It also contains metadata like the authors of the text.","title":"`` Table"},{"location":"backend/database/tutorial_related_tables/tutorial/tutorial_table/#mixins","text":"UUIDMixin TimeDateMixin StatusMixin VersionMixin LangMixin","title":"Mixins"},{"location":"backend/database/tutorial_related_tables/tutorial/tutorial_table/#fields","text":"Field Type Description tutorial_anchor FK(TutorialAnchor) The anchor point of this tutorial. authors MTM(User) A list of authors. title models.TextField The title of this tutorial (translated). abstract models.TextField The abstract of this tutorial (translated). content_md models.TextField The content of this tutorial in Markdown (translated) content_html models.TextField The parsed html of the Markdown tutorial (translated)","title":"Fields"},{"location":"backend/database/tutorial_related_tables/uploads/uploads_table/","text":"Uploads Table The Uploads table contains all the upload file used in the textual tutorial content. Mixins UUIDMixin TimeDateMixin Fields Fields Type Description file models.FileField The file pointer to the actual file name models.CharField The descriptive name of the file. tutorial_anchors MTM(TutorialAnchor) graph_anchors MTM(GraphAnchor)","title":"`Uploads` Table"},{"location":"backend/database/tutorial_related_tables/uploads/uploads_table/#uploads-table","text":"The Uploads table contains all the upload file used in the textual tutorial content.","title":"Uploads Table"},{"location":"backend/database/tutorial_related_tables/uploads/uploads_table/#mixins","text":"UUIDMixin TimeDateMixin","title":"Mixins"},{"location":"backend/database/tutorial_related_tables/uploads/uploads_table/#fields","text":"Fields Type Description file models.FileField The file pointer to the actual file name models.CharField The descriptive name of the file. tutorial_anchors MTM(TutorialAnchor) graph_anchors MTM(GraphAnchor)","title":"Fields"},{"location":"backend/database/user_system/user_table/","text":"User Table The user table inherits UUIDMixin and User model. View the link to see more properties of the User model. The inherited model extends User with new properties role and is_verified . Field Type Description role PositiveSmallIntegerField with choices option The role field indicates the privilege this user has. Currently, there are 6 levels (two level more than the first version of Graphery). Listed from high to low are Administrator , Editor , Author , Translator , Visitor , and Reader . Detailed descriptions of each row are listed in the table down below. is_verified BooleanField is_verified is used to indicate whether the user has validated their email or not. Unverified users can't perform certain actions. Detailed descriptions are also listed down below. Also, the unverified users are active within $UNVERIFIED_USER_REMOVE_AFTER days after the registration. has_email_update BooleanField has_email_update is used to indicate whether the user has opted in emails updates when new tutorials are published or when some news is shared by the administrators. role Description Restriction If Unverified Administrator Administrator s have all the privileges: view , add , edit , publish , delete tutorials and other contents, view , add , change , delete users and have access to the Django admin site. Editor Editor s have access to view , add , edit , publish , delete privileges for tutorials and other contents. Author Author s have access to view , add , edit privileges for tutorials and other contents. Translator Translators have access to view and edit privileges for tutorials but only view privileges for other contents. Visitor Visitors can only view the tutorials and other content in the control panel. Reader No special privileges. The overwritten User model requires a matching UserManager . It should overwrite create_user and create_superuser functions. Developers should create User object only through the helper functions.","title":"`User` Table"},{"location":"backend/database/user_system/user_table/#user-table","text":"The user table inherits UUIDMixin and User model. View the link to see more properties of the User model. The inherited model extends User with new properties role and is_verified . Field Type Description role PositiveSmallIntegerField with choices option The role field indicates the privilege this user has. Currently, there are 6 levels (two level more than the first version of Graphery). Listed from high to low are Administrator , Editor , Author , Translator , Visitor , and Reader . Detailed descriptions of each row are listed in the table down below. is_verified BooleanField is_verified is used to indicate whether the user has validated their email or not. Unverified users can't perform certain actions. Detailed descriptions are also listed down below. Also, the unverified users are active within $UNVERIFIED_USER_REMOVE_AFTER days after the registration. has_email_update BooleanField has_email_update is used to indicate whether the user has opted in emails updates when new tutorials are published or when some news is shared by the administrators. role Description Restriction If Unverified Administrator Administrator s have all the privileges: view , add , edit , publish , delete tutorials and other contents, view , add , change , delete users and have access to the Django admin site. Editor Editor s have access to view , add , edit , publish , delete privileges for tutorials and other contents. Author Author s have access to view , add , edit privileges for tutorials and other contents. Translator Translators have access to view and edit privileges for tutorials but only view privileges for other contents. Visitor Visitors can only view the tutorials and other content in the control panel. Reader No special privileges. The overwritten User model requires a matching UserManager . It should overwrite create_user and create_superuser functions. Developers should create User object only through the helper functions.","title":"User Table"},{"location":"backend/executor/implementation/","text":"Implementation executor executor is the name of the module executing user-provided scripts on a particular networkx graph. It has two modes: local and server . To use the executor, the module should be installed by pip and graphery_executor executable will be available for execution. graphery_executor -h can be used to check the supported options and graphery_executor -V can be used to check the installed version. The local mode uses stdin as the input source. The supported API is listed in ./local/API.md . When executed successfully, a formatted json will be printed to stdout , and error messages and stacktrace if otherwise. The server opens up a WSGI server on specified host and port , which are defaulted to 127.0.0.1 and 7590 respectively. The server accepts POST method when queries are posted to /run slug and GET method when /env is the target. When posting to /run , it should follow the local API, i.e. ./local/API.md . When a message is received, the server creates a subprocess, hands the message to a local executor , wraps the stdout from local executor , and send back a response. The response is always 200 OK except when the server goes wrong and 500 Internal Server Error will be returned. Controller A Controller is used in local executor and handles all the execution management. The Controller class takes in three 4 components: runner , context_layers , default_settings , options . The controller is intended to execute the provided runner procedure within the context layers. The controller works in the following way. Instantiated by provided runner , context_layers , default_settings , options , and any keyword arguments. The controller then extracts required information from settings, options, and keyword arguments. Context layers are also initialized during this process. After instantiation, the controller needs to go through init process to be usable. The process can be realized through init or __call__ provided to controllers. The init process collects sets up the environment in which the runner with be performed, most notably the user_global which serves as the global environment for runner . If an error is raised during the init process, the INIT_ERROR_CODE will be used when program exits. Then main procedure from the controller should be called. Once main is called, controller will go into prep process that prepares the variables, modules, and security procedures for runner and call runner if everything is good to go. runner is called by using exec with custom globals and locals made during init process and prep process. Any error happened in prep process will trigger PREP_ERROR_CODE and errors during running runner will trigger RUNNER_ERROR_CODE . If the runner successfully completes, the controller will go into post process so that it can clean up aftermath and remove security procedure. main will return whatever is returned by runner if it completes successfully. Otherwise, ErrorResult is returned. Some context layers are provided by default. _RandomContext sets the random seed to a fix value and release it after exiting. _FDRedirectLayer redirects stdout and stderr to some streams or file descriptors during executing runner and release them after exiting. _ModuleRestrict restricts what modules can be imported in the runner . _ResourceRestrict restricts how much time and memory the runner can consume. A list of options can be used in controller is provided below: Name Default Value Description logger LOGGER from settings Logger instance that will be in controller. When this is not set, the LOGGER in settings will be used. custom_ns {} Custom namespace that will be used in runner environment. The type should be a Mapping . For example, suppose the custom namespace is defined as custom_ns = {'special': 'some_text'} . Then, the runner code can reference special without defining it. stdout StringIO() It's used to specified where the stdout will be captured during executing runner . stderr StringIO() Similar to stdout , but for stderr . formatter ControllerResultFormatter() A formatter specifying how the controller result will be modified. There is no other options for now. GraphController GraphController is a subclass of Controller . The runner baked into the class and should not be provided by caller. But it takes in two additional keyword only arguments: code and graph_data . The GraphController behaves the same as a Controller except a few more steps in init process: it also builds a networkx graph from graph_data , sets up a Recorder and then make a copy of tracer ; it then injects networkx , graph , and tracer to the user_globals so that they can be referenced during the execution of code . ContextLayer The context layer behaves like a standard helper from contextlib and is intended to be used along with clause or in controllers' prep process or post process. It implements __enter__ and __exit__ procedures and have explicit enter and exit procedures available. A context layer takes a controller instance as initialization argument. DefaultVars (Settings) The DefaultVars is used to store option variables and to read and sets values from environment variables if there is any. All variables are listed in the first second of variables.md . The DefaultVars and it's instance support __getitem__ procedure. When a setting name is provided, the corresponding value will be returned by [] operation. It's cumbersome to write setting[setting.IS_LOCAL] so a getter is added, and it's possible to achieve the same thing by using setting.v.IS_LOCAL . In DefaultVars , read_from_env is provided to read value from shell environment variables.","title":"Implementation"},{"location":"backend/executor/implementation/#implementation","text":"","title":"Implementation"},{"location":"backend/executor/implementation/#executor","text":"executor is the name of the module executing user-provided scripts on a particular networkx graph. It has two modes: local and server . To use the executor, the module should be installed by pip and graphery_executor executable will be available for execution. graphery_executor -h can be used to check the supported options and graphery_executor -V can be used to check the installed version. The local mode uses stdin as the input source. The supported API is listed in ./local/API.md . When executed successfully, a formatted json will be printed to stdout , and error messages and stacktrace if otherwise. The server opens up a WSGI server on specified host and port , which are defaulted to 127.0.0.1 and 7590 respectively. The server accepts POST method when queries are posted to /run slug and GET method when /env is the target. When posting to /run , it should follow the local API, i.e. ./local/API.md . When a message is received, the server creates a subprocess, hands the message to a local executor , wraps the stdout from local executor , and send back a response. The response is always 200 OK except when the server goes wrong and 500 Internal Server Error will be returned.","title":"executor"},{"location":"backend/executor/implementation/#controller","text":"A Controller is used in local executor and handles all the execution management. The Controller class takes in three 4 components: runner , context_layers , default_settings , options . The controller is intended to execute the provided runner procedure within the context layers. The controller works in the following way. Instantiated by provided runner , context_layers , default_settings , options , and any keyword arguments. The controller then extracts required information from settings, options, and keyword arguments. Context layers are also initialized during this process. After instantiation, the controller needs to go through init process to be usable. The process can be realized through init or __call__ provided to controllers. The init process collects sets up the environment in which the runner with be performed, most notably the user_global which serves as the global environment for runner . If an error is raised during the init process, the INIT_ERROR_CODE will be used when program exits. Then main procedure from the controller should be called. Once main is called, controller will go into prep process that prepares the variables, modules, and security procedures for runner and call runner if everything is good to go. runner is called by using exec with custom globals and locals made during init process and prep process. Any error happened in prep process will trigger PREP_ERROR_CODE and errors during running runner will trigger RUNNER_ERROR_CODE . If the runner successfully completes, the controller will go into post process so that it can clean up aftermath and remove security procedure. main will return whatever is returned by runner if it completes successfully. Otherwise, ErrorResult is returned. Some context layers are provided by default. _RandomContext sets the random seed to a fix value and release it after exiting. _FDRedirectLayer redirects stdout and stderr to some streams or file descriptors during executing runner and release them after exiting. _ModuleRestrict restricts what modules can be imported in the runner . _ResourceRestrict restricts how much time and memory the runner can consume. A list of options can be used in controller is provided below: Name Default Value Description logger LOGGER from settings Logger instance that will be in controller. When this is not set, the LOGGER in settings will be used. custom_ns {} Custom namespace that will be used in runner environment. The type should be a Mapping . For example, suppose the custom namespace is defined as custom_ns = {'special': 'some_text'} . Then, the runner code can reference special without defining it. stdout StringIO() It's used to specified where the stdout will be captured during executing runner . stderr StringIO() Similar to stdout , but for stderr . formatter ControllerResultFormatter() A formatter specifying how the controller result will be modified. There is no other options for now.","title":"Controller"},{"location":"backend/executor/implementation/#graphcontroller","text":"GraphController is a subclass of Controller . The runner baked into the class and should not be provided by caller. But it takes in two additional keyword only arguments: code and graph_data . The GraphController behaves the same as a Controller except a few more steps in init process: it also builds a networkx graph from graph_data , sets up a Recorder and then make a copy of tracer ; it then injects networkx , graph , and tracer to the user_globals so that they can be referenced during the execution of code .","title":"GraphController"},{"location":"backend/executor/implementation/#contextlayer","text":"The context layer behaves like a standard helper from contextlib and is intended to be used along with clause or in controllers' prep process or post process. It implements __enter__ and __exit__ procedures and have explicit enter and exit procedures available. A context layer takes a controller instance as initialization argument.","title":"ContextLayer"},{"location":"backend/executor/implementation/#defaultvars-settings","text":"The DefaultVars is used to store option variables and to read and sets values from environment variables if there is any. All variables are listed in the first second of variables.md . The DefaultVars and it's instance support __getitem__ procedure. When a setting name is provided, the corresponding value will be returned by [] operation. It's cumbersome to write setting[setting.IS_LOCAL] so a getter is added, and it's possible to achieve the same thing by using setting.v.IS_LOCAL . In DefaultVars , read_from_env is provided to read value from shell environment variables.","title":"DefaultVars (Settings)"},{"location":"backend/executor/introduction/","text":"Execution Server Executor This is a specification for the execution server, which is different from the webserver and severs execution results. This folder contains the API the execution server follows and exposes, as well as some design choices. See implementation.md for more detail.","title":"Execution Server `Executor`"},{"location":"backend/executor/introduction/#execution-server-executor","text":"This is a specification for the execution server, which is different from the webserver and severs execution results. This folder contains the API the execution server follows and exposes, as well as some design choices. See implementation.md for more detail.","title":"Execution Server Executor"},{"location":"backend/executor/variables/","text":"Variables Environment Variables The executor uses a bunch of environment variables to determine the content it serves. Every environment variable is listed below and when used in shell environment, each should be prefixed with GE_ which is short for graphery executor. For example, if the server port is to be set ot 23032 , export GE_SERVER_PORT=23032 can be used. Variable Default Value Description SERVER_URL 127.0.0.1 The URL used to access the executor server. SERVER_PORT 7590 The port used to access the executor server. ALLOW_OTHER_ORIGIN True If other origins are allowed other than ACCEPTED_ORIGINS ACCEPTED_ORIGINS ['127.0.0.1'] The allowed origins that can access the executor server. LOGGER shell_info_logger Info level logs are displayed on shell by default. EXEC_TIME_OUT 5 The time, in seconds, during which the executor is allowed to run. EXEC_MEM_OUT 100 The size, in Mb, which the program can occupy. IS_LOCAL False Indicator of whether the script is running locally. If this is turned on, the server ignores every security check. RAND_SEED 0 The default random seed used in simulation. None or integers can be used. FLOAT_PRECISION 4 The number of float precision. Integers can be used. Variable Default Value Description REQUEST_DATA_CODE_NAME code The name of code field in the request object. REQUEST_DATA_GRAPH_NAME graph The name of graph field in the request object. REQUEST_DATA_VERSION_NAME version The name of version field in the request object. REQUEST_DATA_OPTIONS_NAME options The name of options field in the request object. Docker Environment Variables Variable Default Value Description GE_DOCKER_RESTART_COND unless-stopped Indicate which stop policy the docker should implement. REF GE_DOCKER_RESTART_WINDOW 10 The unit is s econd. The time docker should wait before deciding if the restart has succeeded or not. REF GE_DOCKER_MEM_OUT 32 The unit is M egibyte. The maximum amount of memory docker image can take. Exceeding the limit will issue system kill. GE_DOCKER_CPU_OUT 0.10 The unit is % . The percentage of CPU the container can use. Custom Variables Custom variables are variables referenced within executor and are not intended to be modified. Variable Value Description PROG_NAME graphery_executor The program name used by pip executable and internal server. SERVER_VERSION 3.0.0 The version of this server. The first digit of the server version matches the version of the result JSON API version. IDENTIFIER_SEPARATOR \"\\u200b@\" The identifier separator used by recorder. GRAPH_INJECTION_NAME graph The name the tutorial graph take when injected into the execution environment. NX_GRAPH_INJECTION_NAME g_graph The name the tutorial graph take when injected into the networkx module. Error Code The exit code return by executor when running locally. Variable Value Description CTRL_ERROR_CODE 3 Some error happened within controller and should be reported to maintainers. INIT_ERROR_CODE 5 Some error happened within the controller init process. This is mostly caused by erroneous input. PREP_ERROR_CODE 7 Some error happened within the controller prep process. They are mostly issues from controller. POST_ERROR_CODE 11 Some error happened within the controller post process. They are also mostly issues from controller. RUNNER_ERROR_CODE 13 Some error happened during running user code. This is caused by user-provided script. CPU_OUT_EXIT_CODE 17 This indicates the CPU time runs out. MEM_OUT_EXIT_CODE 19 This indicates the allocated Memory is consumed. Shell Args Variable Value Description SHELL_PARSER_GROUP_NAME WHERE The Namespace attribute name of the executor mode, the value should be either value below. SHELL_SERVER_PARSER_NAME server A possible value of WHERE , indicating the running mode is server mode. SHELL_LOCAL_PARSER_NAME local A possible value of WHERE , indicating the running mode is local mode.","title":"Variables"},{"location":"backend/executor/variables/#variables","text":"","title":"Variables"},{"location":"backend/executor/variables/#environment-variables","text":"The executor uses a bunch of environment variables to determine the content it serves. Every environment variable is listed below and when used in shell environment, each should be prefixed with GE_ which is short for graphery executor. For example, if the server port is to be set ot 23032 , export GE_SERVER_PORT=23032 can be used. Variable Default Value Description SERVER_URL 127.0.0.1 The URL used to access the executor server. SERVER_PORT 7590 The port used to access the executor server. ALLOW_OTHER_ORIGIN True If other origins are allowed other than ACCEPTED_ORIGINS ACCEPTED_ORIGINS ['127.0.0.1'] The allowed origins that can access the executor server. LOGGER shell_info_logger Info level logs are displayed on shell by default. EXEC_TIME_OUT 5 The time, in seconds, during which the executor is allowed to run. EXEC_MEM_OUT 100 The size, in Mb, which the program can occupy. IS_LOCAL False Indicator of whether the script is running locally. If this is turned on, the server ignores every security check. RAND_SEED 0 The default random seed used in simulation. None or integers can be used. FLOAT_PRECISION 4 The number of float precision. Integers can be used. Variable Default Value Description REQUEST_DATA_CODE_NAME code The name of code field in the request object. REQUEST_DATA_GRAPH_NAME graph The name of graph field in the request object. REQUEST_DATA_VERSION_NAME version The name of version field in the request object. REQUEST_DATA_OPTIONS_NAME options The name of options field in the request object.","title":"Environment Variables"},{"location":"backend/executor/variables/#docker-environment-variables","text":"Variable Default Value Description GE_DOCKER_RESTART_COND unless-stopped Indicate which stop policy the docker should implement. REF GE_DOCKER_RESTART_WINDOW 10 The unit is s econd. The time docker should wait before deciding if the restart has succeeded or not. REF GE_DOCKER_MEM_OUT 32 The unit is M egibyte. The maximum amount of memory docker image can take. Exceeding the limit will issue system kill. GE_DOCKER_CPU_OUT 0.10 The unit is % . The percentage of CPU the container can use.","title":"Docker Environment Variables"},{"location":"backend/executor/variables/#custom-variables","text":"Custom variables are variables referenced within executor and are not intended to be modified. Variable Value Description PROG_NAME graphery_executor The program name used by pip executable and internal server. SERVER_VERSION 3.0.0 The version of this server. The first digit of the server version matches the version of the result JSON API version. IDENTIFIER_SEPARATOR \"\\u200b@\" The identifier separator used by recorder. GRAPH_INJECTION_NAME graph The name the tutorial graph take when injected into the execution environment. NX_GRAPH_INJECTION_NAME g_graph The name the tutorial graph take when injected into the networkx module.","title":"Custom Variables"},{"location":"backend/executor/variables/#error-code","text":"The exit code return by executor when running locally. Variable Value Description CTRL_ERROR_CODE 3 Some error happened within controller and should be reported to maintainers. INIT_ERROR_CODE 5 Some error happened within the controller init process. This is mostly caused by erroneous input. PREP_ERROR_CODE 7 Some error happened within the controller prep process. They are mostly issues from controller. POST_ERROR_CODE 11 Some error happened within the controller post process. They are also mostly issues from controller. RUNNER_ERROR_CODE 13 Some error happened during running user code. This is caused by user-provided script. CPU_OUT_EXIT_CODE 17 This indicates the CPU time runs out. MEM_OUT_EXIT_CODE 19 This indicates the allocated Memory is consumed.","title":"Error Code"},{"location":"backend/executor/variables/#shell-args","text":"Variable Value Description SHELL_PARSER_GROUP_NAME WHERE The Namespace attribute name of the executor mode, the value should be either value below. SHELL_SERVER_PARSER_NAME server A possible value of WHERE , indicating the running mode is server mode. SHELL_LOCAL_PARSER_NAME local A possible value of WHERE , indicating the running mode is local mode.","title":"Shell Args"},{"location":"backend/executor/local/API/","text":"API Introduction This API is for the local mode. 3.0 The local mode is started by shell. The usage is listed below. usage: graphery_executor [ -h ] [ -V ] [ -t EXEC_TIME_OUT ] [ -m EXEC_MEM_OUT ] [ -i ] [ -r RAND_SEED ] [ -f FLOAT_PRECISION ] [ -l { void, shell_debug, shell_info }] { server,local } ... Graphery Executor Server positional arguments: { server,local } options: -h, --help show this help message and exit -V, --version show program ' s version number and exit -t EXEC_TIME_OUT, --time-out EXEC_TIME_OUT -m EXEC_MEM_OUT, --mem-out EXEC_MEM_OUT -i, --is-local -r RAND_SEED, --rand-seed RAND_SEED -f FLOAT_PRECISION, --float-precision FLOAT_PRECISION -l { void, shell_debug, shell_info } , --logger { void, shell_debug, shell_info } The minimal command is graphery_executor local , and a piece of request data must be fed through stdin as input. For the format of request data, please check out server API , and the response is formatted as record_array_type which is detailed here .","title":"API"},{"location":"backend/executor/local/API/#api","text":"","title":"API"},{"location":"backend/executor/local/API/#introduction","text":"This API is for the local mode.","title":"Introduction"},{"location":"backend/executor/local/API/#30","text":"The local mode is started by shell. The usage is listed below. usage: graphery_executor [ -h ] [ -V ] [ -t EXEC_TIME_OUT ] [ -m EXEC_MEM_OUT ] [ -i ] [ -r RAND_SEED ] [ -f FLOAT_PRECISION ] [ -l { void, shell_debug, shell_info }] { server,local } ... Graphery Executor Server positional arguments: { server,local } options: -h, --help show this help message and exit -V, --version show program ' s version number and exit -t EXEC_TIME_OUT, --time-out EXEC_TIME_OUT -m EXEC_MEM_OUT, --mem-out EXEC_MEM_OUT -i, --is-local -r RAND_SEED, --rand-seed RAND_SEED -f FLOAT_PRECISION, --float-precision FLOAT_PRECISION -l { void, shell_debug, shell_info } , --logger { void, shell_debug, shell_info } The minimal command is graphery_executor local , and a piece of request data must be fed through stdin as input. For the format of request data, please check out server API , and the response is formatted as record_array_type which is detailed here .","title":"3.0"},{"location":"backend/executor/server/API/","text":"API Introduction There are two sets of API, one for server mode and one for local mode. This API is for server mode. For local mode, please check out here . 3.0 API Request The request object looks like the following. interface request_object { code : string ; graph : string | object ; version : string ; options? : request_options ; } interface request_options { rand_seed? : int ; float_precision? : int ; input_list? : string []; } If any of the request options is undefined, we use the default options to make sure it doesn't have undefined fields. let default_request_options : request_options = { rand_seed : 0 , float_precision : 4 , input_list : [] } Response where the record_array_type is defined in the result JSON API . type err_msg_type = { message : string ; traceback : string ; }; type response_info_type = { result : record_array_type , [ key : string ] : any } interface response_object_type { info : response_info_type | null ; errors : err_msg_type [] | null ; } interface successful_response_object_type extends response_object_type { info : response_info_type errors : null ; } interface error_response_object_type extends response_object_type { info : null ; errors : err_msg_type []; }","title":"API"},{"location":"backend/executor/server/API/#api","text":"","title":"API"},{"location":"backend/executor/server/API/#introduction","text":"There are two sets of API, one for server mode and one for local mode. This API is for server mode. For local mode, please check out here .","title":"Introduction"},{"location":"backend/executor/server/API/#30-api","text":"","title":"3.0 API"},{"location":"backend/executor/server/API/#request","text":"The request object looks like the following. interface request_object { code : string ; graph : string | object ; version : string ; options? : request_options ; } interface request_options { rand_seed? : int ; float_precision? : int ; input_list? : string []; } If any of the request options is undefined, we use the default options to make sure it doesn't have undefined fields. let default_request_options : request_options = { rand_seed : 0 , float_precision : 4 , input_list : [] }","title":"Request"},{"location":"backend/executor/server/API/#response","text":"where the record_array_type is defined in the result JSON API . type err_msg_type = { message : string ; traceback : string ; }; type response_info_type = { result : record_array_type , [ key : string ] : any } interface response_object_type { info : response_info_type | null ; errors : err_msg_type [] | null ; } interface successful_response_object_type extends response_object_type { info : response_info_type errors : null ; } interface error_response_object_type extends response_object_type { info : null ; errors : err_msg_type []; }","title":"Response"},{"location":"frontend/introduction/","text":"Introduction","title":"Introduction"},{"location":"frontend/introduction/#introduction","text":"","title":"Introduction"},{"location":"frontend/event-bus/introduction/","text":"Introduction Event Bus is used to help organize interactions among components. The full list of events can be found in the repository here . The underlying lib is mitt . This directory will introduce the events and their workflows.","title":"Introduction"},{"location":"frontend/event-bus/introduction/#introduction","text":"Event Bus is used to help organize interactions among components. The full list of events can be found in the repository here . The underlying lib is mitt . This directory will introduce the events and their workflows.","title":"Introduction"},{"location":"frontend/event-bus/workflows/","text":"Workflows Tutorial Page Workflow This subsection is dedicated to introduce the workflow in the tutorial page. The tutorial page is a page consisting of three sections: text section, graphing section, and code+variable section. This workflow is strongly connected to storage transaction, and as a result it controls data fetching, loading, and packaging. The purpose of this is to allow view components to use the packaged getters right away without worrying about processing. When the page is loaded, the event fetch-tutorial will be emitted, to signal the storage action to fetch tutorial content from the server. This event will command the storage to download the information of the tutorial, given the tutorial url and target language. The information contains the text content, code, and identifiers of graphs. Once the fetching action is executed, an fetched-tutorial event will then be emitted. It will also trigger several other events: fetched-tutorial , and subsequently and load-code if fetching is executed successfully. When load-code is dispatched, the current code id will be set to the proper code identifier, and a getter will automatically register the proper code object so that the editor component can use. When the identifiers are loaded, the graph selector component will display available graphs and automatically try to fetch the first graph. (Since the fetched tutorial contains only the graph identifier instead of all information of the graph, the information has to be fetched in separate calls.) Along side of loading graph information, the execution record array is also fetched, installed into the storage, and served by a getter so that the frontend can display properly. Every time a new execution record is loaded, the record state will be reset by calling the reset-state event.","title":"Workflows"},{"location":"frontend/event-bus/workflows/#workflows","text":"","title":"Workflows"},{"location":"frontend/event-bus/workflows/#tutorial-page-workflow","text":"This subsection is dedicated to introduce the workflow in the tutorial page. The tutorial page is a page consisting of three sections: text section, graphing section, and code+variable section. This workflow is strongly connected to storage transaction, and as a result it controls data fetching, loading, and packaging. The purpose of this is to allow view components to use the packaged getters right away without worrying about processing. When the page is loaded, the event fetch-tutorial will be emitted, to signal the storage action to fetch tutorial content from the server. This event will command the storage to download the information of the tutorial, given the tutorial url and target language. The information contains the text content, code, and identifiers of graphs. Once the fetching action is executed, an fetched-tutorial event will then be emitted. It will also trigger several other events: fetched-tutorial , and subsequently and load-code if fetching is executed successfully. When load-code is dispatched, the current code id will be set to the proper code identifier, and a getter will automatically register the proper code object so that the editor component can use. When the identifiers are loaded, the graph selector component will display available graphs and automatically try to fetch the first graph. (Since the fetched tutorial contains only the graph identifier instead of all information of the graph, the information has to be fetched in separate calls.) Along side of loading graph information, the execution record array is also fetched, installed into the storage, and served by a getter so that the frontend can display properly. Every time a new execution record is loaded, the record state will be reset by calling the reset-state event.","title":"Tutorial Page Workflow"},{"location":"tutorials/introduction/","text":"Introduction","title":"Introduction"},{"location":"tutorials/introduction/#introduction","text":"","title":"Introduction"}]}