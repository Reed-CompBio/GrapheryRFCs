# Bridge Base

This file contains building blocks helping construct *data bridge* objects. It contains `DataBridgeMeta`, `DataBridgeProtocol`, and `DataBridgeBase`. `DataBridgeMeta` is a meta class implemented by `DataBridgeProtocol`. It constructs data bridge subclasses such each subclass will contain a collection of *bridge functions*, which are functions that validate input and write to the database. The `DataBridgeProtocol` is a protocol class constructed using the `DataBridgeMeta`, serving both as a source of attribute types and type reference in other context. The `DataBridgeBase` inherits `DataBridgeProtocol` and thus implements `DataBridgeMeta`. All *data bridge classes* should inherits `DataBridgeBase` instead of other bases.

Every *data bridge class* must override the class attribute `_bridged_model_cls` so that it contains the Django model class as an indication that the the instances of this data bridge class will pipe inputs to that kind of Django model instance. As a result, in the creation process of the data bridge class, `DataBridgeMeta`  serves as its meta class and collects *bridge functions*, which will be stored in `_bridges` class variable. `DataBridgeMeta` also makes sure the naming of bridge functions align with the fields in the model specified in `_bridged_model_cls`.

Bridge functions are like pipes or middleware between API inputs and the database. It validates the input data and safely stores it into the database.  Bridge functions should have their name start with the name `_bridges_` following with the field name, that is, it follows the format `_bridges_<field_name>`. For example, `_bridges_status` is a bridge function operating on the field `status`. If the `<field_name>` of some bridge function is not present in Django model, an error will be raised. If some field in the `_bridge_model` does not have a bridge function, an error will be raised only if programmers try to pipe data to the field through the data bridge to that particular field.

The metaclass also wraps each bridge function with a basic permission validator. Whether or not a permission and which level of permission is required should be indicated in the class variable `_require_authentication` and `_minimal_user_role`. It's defaulted to be open to everyone.

In addition, there is a `_custom_fields` class attribute and a `_attaching_to` class attribute. `_custom_fields` allows bridge functions whose `<field_name>` is not specified in the corresponding Django model to exist. For example, `User` model has a field called `password` but not one named `new_password`. With `new_password` added into `_custom_fields`, the data bridge class is allowed to declare `_bridges_new_password` bridge function.

 `_attaching_to` is a little more complicated. It should be a tuple of strings, with each string being a name of a field in `_bridge_model`, indicating that a instance of `_bridge_model` cannot exist if those fields are empty. For example, if the `_attaching_to` field is set to `("a", "b")` and if either the data piped to the field `a` ***or*** `b` is empty, the model instance will hopefully be deleted or at least not exist after bridging.
